<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Attendance - Professional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        .video-container { 
            border: 10px solid white; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 6px 20px rgba(0,0,0,0.1); 
            border-radius: 8px; 
            background: white; 
            position: relative; 
            overflow: hidden; 
            aspect-ratio: 4/3;
        }
        .btn { transition: all 0.2s ease-in-out; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .btn:active { transform: translateY(0); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        input:read-only { background-color: #f3f4f6; cursor: not-allowed; }
        .btn-loader { 
            border: 2px solid #f3f3f3; 
            border-top: 2px solid #ffffff; 
            border-radius: 50%; 
            width: 16px; 
            height: 16px; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .fade-in { animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background-color: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            border-radius: 8px 8px 0 0;
        }
        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #64748b;
        }
        .status-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto bg-white rounded-xl shadow-2xl overflow-hidden">
        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div id="network-status-icon" class="status-icon">
                    <i class="fas fa-circle-notch fa-spin text-gray-400"></i>
                </div>
                <span id="network-status-text">Network</span>
            </div>
            <div class="status-item">
                <div id="camera-status-icon" class="status-icon">
                    <i class="fas fa-circle-notch fa-spin text-gray-400"></i>
                </div>
                <span id="camera-status-text">Camera</span>
            </div>
            <div class="status-item">
                <div id="sync-status-icon" class="status-icon">
                    <i class="fas fa-circle-notch fa-spin text-gray-400"></i>
                </div>
                <span id="sync-status-text">Sync</span>
            </div>
            <div class="status-item">
                <div class="status-icon">
                    <i class="fas fa-clock text-gray-400"></i>
                </div>
                <span id="real-time-clock">--:--:--</span>
            </div>
        </div>
        
        <div class="p-6 md:p-8 space-y-5">
            <header class="text-center">
                <h1 class="text-2xl md:text-3xl font-bold text-gray-800">Smart Attendance</h1>
            </header>

            <main id="app-content" class="space-y-4">
                <div class="video-container">
                    <video id="camera-feed" autoplay playsinline class="w-full h-full object-cover rounded-sm bg-gray-200"></video>
                    <canvas id="photo-canvas" class="hidden"></canvas>
                    <div class="absolute bottom-2 right-2 flex gap-2">
                        <button id="torch-btn" class="p-2 bg-white/50 backdrop-blur-sm rounded-full btn hidden" title="Toggle Flash/Torch"></button>
                        <button id="switch-camera-btn" class="p-2 bg-white/50 backdrop-blur-sm rounded-full btn hidden" title="Switch Camera"></button>
                    </div>
                </div>
                
                <div class="space-y-3">
                    <div>
                        <label for="emp-id" class="block text-sm font-medium text-gray-700 mb-1">Employee ID</label>
                        <input type="text" id="emp-id" placeholder="Loading data..." disabled class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="text-sm text-center">
                        <a href="#" id="toggle-location-btn" class="text-blue-600 hover:underline">Working from Outside?</a>
                    </div>
                    <div id="location-options-div" class="hidden space-y-2 rounded-lg bg-gray-50 p-3 transition-all duration-300">
                        <p class="text-sm font-medium text-gray-700">Location Type</p>
                        <div class="flex items-center space-x-6">
                            <div class="flex items-center"><input id="loc-inside" name="location-type" type="radio" value="Inside Office" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500"><label for="loc-inside" class="ml-2 block text-sm text-gray-900">Inside Office</label></div>
                            <div class="flex items-center"><input id="loc-outside" name="location-type" type="radio" value="Outside" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500"><label for="loc-outside" class="ml-2 block text-sm text-gray-900">Outside</label></div>
                        </div>
                    </div>
                    <div>
                        <label for="name" class="block text-sm font-medium text-gray-700 mb-1">Full Name</label>
                        <input type="text" id="name" placeholder="Auto-filled" readonly class="w-full px-4 py-2 border border-gray-300 rounded-lg">
                    </div>
                     <div>
                        <label for="department" class="block text-sm font-medium text-gray-700 mb-1">Department</label>
                        <input type="text" id="department" placeholder="Auto-filled" readonly class="w-full px-4 py-2 border border-gray-300 rounded-lg">
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <button id="in-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg btn flex justify-center items-center gap-2" disabled>
                        <i class="fas fa-sign-in-alt"></i>
                        <span class="btn-text">IN</span>
                    </button>
                    <button id="out-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg btn flex justify-center items-center gap-2" disabled>
                        <i class="fas fa-sign-out-alt"></i>
                        <span class="btn-text">OUT</span>
                    </button>
                </div>

                <div id="status-message" class="text-center text-sm font-medium p-3 rounded-lg hidden fade-in"></div>
                
                <div id="offline-queue" class="hidden text-center text-xs text-gray-500">
                    <i class="fas fa-database mr-1"></i>
                    <span id="offline-count">0</span> pending offline records
                </div>
            </main>
            
            <footer class="text-center pt-4 border-t border-gray-200">
                <p class="text-xs text-gray-400">Developed by Amit Kumar | <span class="font-medium">v1.2.2</span></p>
            </footer>
        </div>
    </div>

    <script>
        // --- Constants ---
        const MAX_RETRIES = 3;
        const SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes
        const TIME_SYNC_INTERVAL = 30 * 60 * 1000; // 30 minutes
        const CAMERA_CHECK_INTERVAL = 5000; // 5 seconds
        
        // --- Element References ---
        const elements = {
            clock: document.getElementById('real-time-clock'),
            video: document.getElementById('camera-feed'), 
            canvas: document.getElementById('photo-canvas'),
            torchBtn: document.getElementById('torch-btn'), 
            switchCameraBtn: document.getElementById('switch-camera-btn'),
            empIdInput: document.getElementById('emp-id'), 
            nameInput: document.getElementById('name'), 
            departmentInput: document.getElementById('department'),
            inBtn: document.getElementById('in-btn'), 
            outBtn: document.getElementById('out-btn'),
            statusMessage: document.getElementById('status-message'),
            toggleLocationBtn: document.getElementById('toggle-location-btn'),
            locationOptionsDiv: document.getElementById('location-options-div'),
            offlineQueue: document.getElementById('offline-queue'),
            offlineCount: document.getElementById('offline-count'),
            networkStatusIcon: document.getElementById('network-status-icon'),
            networkStatusText: document.getElementById('network-status-text'),
            cameraStatusIcon: document.getElementById('camera-status-icon'),
            cameraStatusText: document.getElementById('camera-status-text'),
            syncStatusIcon: document.getElementById('sync-status-icon'),
            syncStatusText: document.getElementById('sync-status-text')
        };

        // --- App State ---
        const state = {
            GAS_URL: 'YOUR_DEPLOYED_WEB_APP_URL', // REPLACE WITH YOUR URL
            employeeDatabase: {}, 
            videoDevices: [], 
            currentDeviceIndex: 0,
            currentStream: null, 
            isTorchSupported: false, 
            isTorchOn: false,
            serverTimeOffset: 0,
            pendingSync: false,
            retryCount: 0,
            lastCameraCheck: 0,
            isOnline: navigator.onLine
        };

        // --- Status Bar Functions ---
        function updateNetworkStatus(online) {
            state.isOnline = online;
            if (online) {
                elements.networkStatusIcon.innerHTML = '<i class="fas fa-wifi text-green-500"></i>';
                elements.networkStatusText.textContent = 'Online';
                elements.networkStatusText.className = 'text-green-600';
            } else {
                elements.networkStatusIcon.innerHTML = '<i class="fas fa-wifi-slash text-red-500"></i>';
                elements.networkStatusText.textContent = 'Offline';
                elements.networkStatusText.className = 'text-red-600';
            }
        }

        function updateCameraStatus(active) {
            if (active) {
                elements.cameraStatusIcon.innerHTML = '<i class="fas fa-video text-green-500"></i>';
                elements.cameraStatusText.textContent = 'Active';
                elements.cameraStatusText.className = 'text-green-600';
            } else {
                elements.cameraStatusIcon.innerHTML = '<i class="fas fa-video-slash text-red-500"></i>';
                elements.cameraStatusText.textContent = 'Inactive';
                elements.cameraStatusText.className = 'text-red-600';
            }
        }

        function updateSyncStatus(syncing, success = true) {
            if (syncing) {
                elements.syncStatusIcon.innerHTML = '<i class="fas fa-circle-notch fa-spin text-blue-500"></i>';
                elements.syncStatusText.textContent = 'Syncing';
                elements.syncStatusText.className = 'text-blue-600';
            } else {
                if (success) {
                    elements.syncStatusIcon.innerHTML = '<i class="fas fa-check-circle text-green-500"></i>';
                    elements.syncStatusText.textContent = 'Synced';
                    elements.syncStatusText.className = 'text-green-600';
                } else {
                    elements.syncStatusIcon.innerHTML = '<i class="fas fa-exclamation-circle text-yellow-500"></i>';
                    elements.syncStatusText.textContent = 'Pending';
                    elements.syncStatusText.className = 'text-yellow-600';
                }
            }
        }

        // --- Utility & UI Functions ---
        function showStatus(message, type = 'info') {
            const colors = {
                info: 'bg-blue-100 text-blue-800',
                success: 'bg-green-100 text-green-800',
                warning: 'bg-yellow-100 text-yellow-800',
                error: 'bg-red-100 text-red-800'
            };
            
            elements.statusMessage.className = `text-center text-sm font-medium p-3 rounded-lg fade-in ${colors[type]}`;
            elements.statusMessage.textContent = message;
            elements.statusMessage.classList.remove('hidden');
            
            // Auto-hide after 5 seconds for non-error messages
            if (type !== 'error') {
                setTimeout(() => {
                    elements.statusMessage.classList.add('hidden');
                }, 5000);
            }
        }

        function toggleButtonLoader(button, isLoading) {
            const btnText = button.querySelector('.btn-text');
            const btnIcon = button.querySelector('i');
            
            if (isLoading) {
                button.disabled = true;
                const loader = document.createElement('div');
                loader.className = 'btn-loader';
                button.insertBefore(loader, btnText);
                btnText.classList.add('hidden');
                btnIcon.classList.add('hidden');
            } else {
                button.disabled = false;
                const loader = button.querySelector('.btn-loader');
                if (loader) loader.remove();
                btnText.classList.remove('hidden');
                btnIcon.classList.remove('hidden');
            }
        }
        
        function updateOfflineQueueIndicator() {
            const queue = JSON.parse(localStorage.getItem('pending_attendance')) || [];
            if (queue.length > 0) {
                elements.offlineQueue.classList.remove('hidden');
                elements.offlineCount.textContent = queue.length;
            } else {
                elements.offlineQueue.classList.add('hidden');
            }
        }

        // --- Core Logic ---
        async function getServerTime() {
            try {
                const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata');
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                const serverTime = new Date(data.utc_datetime);
                state.serverTimeOffset = serverTime.getTime() - Date.now();
                return serverTime;
            } catch (error) {
                console.warn("Could not fetch server time, using local time.", error);
                showStatus("Could not get server time. Using device time.", "warning");
                return new Date();
            }
        }

        function startClock() {
            // Initial sync
            getServerTime().then(() => {
                // Regular time sync
                setInterval(getServerTime, TIME_SYNC_INTERVAL);
                
                // Update clock display every second
                setInterval(() => {
                    const localTime = new Date(Date.now() + state.serverTimeOffset);
                    elements.clock.textContent = localTime.toLocaleTimeString('en-IN', { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit' 
                    });
                }, 1000);
            });
        }
        
        function handleNetworkStatus() {
            const updateStatus = () => {
                const online = navigator.onLine;
                updateNetworkStatus(online);
                
                if (online) {
                    if (!state.pendingSync) {
                        state.pendingSync = true;
                        updateSyncStatus(true);
                        syncOfflineData().finally(() => {
                            state.pendingSync = false;
                        });
                    }
                } else {
                    showStatus('You are offline. Attendance will be saved locally.', 'warning');
                }
            };
            
            updateStatus();
            window.addEventListener('online', updateStatus);
            window.addEventListener('offline', updateStatus);
        }

        async function syncOfflineData() {
            let queue = JSON.parse(localStorage.getItem('pending_attendance')) || [];
            if (queue.length === 0) {
                updateOfflineQueueIndicator();
                updateSyncStatus(false, true);
                return;
            }
            
            showStatus(`Syncing ${queue.length} offline record(s)...`, 'info');
            
            const successfullySyncedIds = [];
            
            for (const data of queue) {
                if (state.retryCount >= MAX_RETRIES) {
                    showStatus('Max retries reached. Will try again later.', 'warning');
                    updateSyncStatus(false, false);
                    break;
                }
                
                try {
                    const response = await fetch(state.GAS_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });
                    
                    const result = await response.json();
                    if (result.status === 'success') {
                        successfullySyncedIds.push(data.id);
                        state.retryCount = 0; // Reset retry count on success
                    } else {
                        throw new Error(result.message);
                    }
                } catch (error) {
                    console.error('Failed to sync item:', data.id, error);
                    state.retryCount++;
                    break; 
                }
            }

            if (successfullySyncedIds.length > 0) {
                let currentQueue = JSON.parse(localStorage.getItem('pending_attendance')) || [];
                let newQueue = currentQueue.filter(item => !successfullySyncedIds.includes(item.id));
                localStorage.setItem('pending_attendance', JSON.stringify(newQueue));
                showStatus('Offline data synced successfully!', 'success');
                updateOfflineQueueIndicator();
            }
            
            // Update sync status
            if (queue.length > successfullySyncedIds.length) {
                updateSyncStatus(false, false);
                setTimeout(syncOfflineData, SYNC_INTERVAL);
            } else {
                updateSyncStatus(false, true);
            }
        }

        function checkCameraActive() {
            if (!state.currentStream) return false;
            
            const videoTracks = state.currentStream.getVideoTracks();
            if (videoTracks.length === 0) return false;
            
            const track = videoTracks[0];
            return track.readyState === 'live';
        }

        function monitorCamera() {
            const now = Date.now();
            if (now - state.lastCameraCheck < CAMERA_CHECK_INTERVAL) return;
            
            state.lastCameraCheck = now;
            const isActive = checkCameraActive();
            updateCameraStatus(isActive);
            
            if (!isActive) {
                showStatus('Camera disconnected. Reconnecting...', 'warning');
                initializeCamera();
            }
        }

        async function initializeCamera() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                    throw new Error('Camera API not supported');
                }
                
                // Get available video devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                state.videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (state.videoDevices.length === 0) {
                    throw new Error('No cameras found');
                }
                
                await startStream();
                
                // Show camera controls if multiple cameras or torch is supported
                if (state.videoDevices.length > 1) {
                    elements.switchCameraBtn.classList.remove('hidden');
                }
                
                checkTorchSupport();
                updateCameraStatus(true);
                
                // Start monitoring camera state
                setInterval(monitorCamera, CAMERA_CHECK_INTERVAL);
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                showStatus('Camera access failed: ' + error.message, 'error');
                elements.video.style.display = 'none';
                updateCameraStatus(false);
            }
        }
        
        async function startStream() {
            // Stop any existing stream
            if (state.currentStream) {
                state.currentStream.getTracks().forEach(track => track.stop());
            }
            
            try {
                const constraints = {
                    video: {
                        deviceId: state.videoDevices[state.currentDeviceIndex].deviceId ? 
                            { exact: state.videoDevices[state.currentDeviceIndex].deviceId } : true,
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: state.currentDeviceIndex === 0 ? 'user' : 'environment'
                    }
                };
                
                state.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = state.currentStream;
                
                // Check torch support for this specific device
                checkTorchSupport();
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                showStatus('Could not access camera: ' + error.message, 'error');
                updateCameraStatus(false);
            }
        }
        
        function checkTorchSupport() {
            if (!state.currentStream) return;
            
            const track = state.currentStream.getVideoTracks()[0];
            if (!track) return;
            
            if ('getCapabilities' in track) {
                const capabilities = track.getCapabilities();
                state.isTorchSupported = capabilities.torch ? true : false;
            } else {
                // Fallback for browsers that don't support getCapabilities
                state.isTorchSupported = false;
            }
            
            if (state.isTorchSupported) {
                elements.torchBtn.classList.remove('hidden');
                elements.torchBtn.innerHTML = '<i class="fas fa-lightbulb"></i>';
            } else {
                elements.torchBtn.classList.add('hidden');
            }
        }
        
        async function toggleTorch() {
            if (!state.currentStream || !state.isTorchSupported) return;
            
            const track = state.currentStream.getVideoTracks()[0];
            if (!track) return;
            
            try {
                await track.applyConstraints({
                    advanced: [{ torch: !state.isTorchOn }]
                });
                state.isTorchOn = !state.isTorchOn;
                elements.torchBtn.innerHTML = state.isTorchOn ? '<i class="fas fa-lightbulb text-yellow-300"></i>' : '<i class="fas fa-lightbulb"></i>';
            } catch (error) {
                console.error('Error toggling torch:', error);
                state.isTorchSupported = false;
                elements.torchBtn.classList.add('hidden');
            }
        }
        
        async function fetchEmployeeData() {
            try {
                const response = await fetch(`${state.GAS_URL}?action=getEmployees`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success' && result.data) {
                    state.employeeDatabase = result.data;
                    elements.empIdInput.placeholder = "Enter your Employee ID";
                    enableInputs();
                } else {
                    throw new Error(result.message || 'Failed to load employee data');
                }
            } catch (error) {
                console.error('Error fetching employee data:', error);
                showStatus('Error loading employee data: ' + error.message, 'error');
                elements.empIdInput.placeholder = "Error loading data";
                
                // Retry after 5 seconds
                setTimeout(fetchEmployeeData, 5000);
            }
        }
        
        function enableInputs() {
            elements.empIdInput.disabled = false;
            elements.inBtn.disabled = false;
            elements.outBtn.disabled = false;
        }
        
        function handleIdInput() {
            const empId = elements.empIdInput.value.trim().toUpperCase();
            
            if (!empId) {
                elements.nameInput.value = '';
                elements.departmentInput.value = '';
                return;
            }
            
            const employee = state.employeeDatabase[empId];
            
            if (employee) {
                elements.nameInput.value = employee.name || '';
                elements.departmentInput.value = employee.department || '';
                
                // Highlight the IN button if it's likely check-in time
                const now = new Date();
                const hours = now.getHours();
                if (hours < 12) { // Morning - likely check-in
                    elements.inBtn.classList.add('pulse');
                    elements.outBtn.classList.remove('pulse');
                } else { // Afternoon - likely check-out
                    elements.outBtn.classList.add('pulse');
                    elements.inBtn.classList.remove('pulse');
                }
            } else {
                elements.nameInput.value = 'Not found';
                elements.departmentInput.value = 'Not found';
                showStatus('Employee ID not found in database', 'warning');
            }
        }
        
        async function markAttendance(status) {
            const empId = elements.empIdInput.value.trim().toUpperCase();
            const name = elements.nameInput.value.trim();
            
            if (!empId || !name || name === 'Not found') {
                showStatus('Please enter a valid Employee ID.', 'warning');
                elements.empIdInput.focus();
                return;
            }
            
            const buttonToLoad = (status === 'IN') ? elements.inBtn : elements.outBtn;
            toggleButtonLoader(buttonToLoad, true);
            
            try {
                // Capture photo with timestamp
                const serverTime = await getServerTime();
                const imageData = await capturePhoto(serverTime);
                
                // Prepare data
                const locationType = document.querySelector('input[name="location-type"]:checked').value;
                
                const dataToSend = {
                    id: `att_${Date.now()}`,
                    action: 'markAttendance', 
                    empId, 
                    name,
                    department: elements.departmentInput.value,
                    locationType,
                    imageData: imageData.split(',')[1],
                    status, 
                    timestamp: serverTime.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })
                };
                
                if (state.isOnline) {
                    try {
                        const response = await fetch(state.GAS_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(dataToSend)
                        });
                        
                        const result = await response.json();
                        if (result.status !== 'success') throw new Error(result.message);
                        
                        showStatus(`Attendance marked as "${status}" successfully!`, 'success');
                        resetForm();
                    } catch (error) {
                        showStatus(`Online submission failed: ${error.message}. Saving locally.`, 'warning');
                        saveOffline(dataToSend);
                    }
                } else {
                    saveOffline(dataToSend);
                }
            } catch (error) {
                showStatus(`Error capturing photo: ${error.message}`, 'error');
            } finally {
                toggleButtonLoader(buttonToLoad, false);
            }
        }
        
        async function capturePhoto(timestamp) {
            return new Promise((resolve) => {
                const context = elements.canvas.getContext('2d');
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
                context.drawImage(elements.video, 0, 0, elements.canvas.width, elements.canvas.height);
                
                // Add timestamp watermark
                if (timestamp) {
                    const timestampText = timestamp.toLocaleString('en-IN', { 
                        dateStyle: 'medium', 
                        timeStyle: 'short' 
                    });
                    
                    context.font = '24px Inter';
                    context.fillStyle = 'white';
                    context.strokeStyle = 'black';
                    context.lineWidth = 4;
                    context.strokeText(timestampText, 20, elements.canvas.height - 20);
                    context.fillText(timestampText, 20, elements.canvas.height - 20);
                }
                
                resolve(elements.canvas.toDataURL('image/jpeg', 0.9));
            });
        }
        
        function saveOffline(data) {
            let queue = JSON.parse(localStorage.getItem('pending_attendance')) || [];
            queue.push(data);
            localStorage.setItem('pending_attendance', JSON.stringify(queue));
            showStatus(`Saved locally (${queue.length} pending). Will sync when online.`, 'warning');
            updateOfflineQueueIndicator();
            updateSyncStatus(false, false);
        }
        
        function resetForm() {
            elements.empIdInput.value = '';
            elements.nameInput.value = '';
            elements.departmentInput.value = '';
            elements.empIdInput.focus();
            elements.inBtn.classList.remove('pulse');
            elements.outBtn.classList.remove('pulse');
        }
        
        function addEventListeners() {
            // Attendance buttons
            elements.inBtn.addEventListener('click', () => markAttendance('IN'));
            elements.outBtn.addEventListener('click', () => markAttendance('OUT'));
            
            // Employee ID input
            elements.empIdInput.addEventListener('blur', handleIdInput);
            elements.empIdInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleIdInput();
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', e => {
                if (e.ctrlKey && e.key.toLowerCase() === 'i') { 
                    e.preventDefault(); 
                    elements.inBtn.click(); 
                }
                if (e.ctrlKey && e.key.toLowerCase() === 'o') { 
                    e.preventDefault(); 
                    elements.outBtn.click(); 
                }
            });
            
            // Camera controls
            elements.switchCameraBtn.addEventListener('click', async () => {
                state.currentDeviceIndex = (state.currentDeviceIndex + 1) % state.videoDevices.length;
                await startStream();
            });
            
            elements.torchBtn.addEventListener('click', toggleTorch);
            
            // Location options
            elements.toggleLocationBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const isHidden = elements.locationOptionsDiv.classList.toggle('hidden');
                e.target.textContent = isHidden ? 'Working from Outside?' : 'Hide Location Options';
            });
        }

        function init() {
            // Initialize status bar
            updateNetworkStatus(navigator.onLine);
            updateCameraStatus(false);
            updateSyncStatus(false);
            
            // Start core functionality
            startClock();
            handleNetworkStatus();
            initializeCamera();
            fetchEmployeeData();
            updateOfflineQueueIndicator();
            
            // Add event listeners
            addEventListeners();
        }
        
        // Start the application
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
